% Nejprve uvedeme tridu dokumentu s volbami
\documentclass[czech,bachelor,public,dept460,male,cpdeclaration,twoside]{diploma}
% Dalsi doplnujici baliky maker
\usepackage{subfig}		% makra pro "podobrazky" a "podtabulky"
\usepackage{tikz}		% makra pro kresleni

% Zadame pozadovane vstupy pro generovani titulnich stran.
\ThesisAuthor{Lukáš Hanusek}

\CzechThesisTitle{Tvorba aplikace pro simulaci problémů v databázovém systému}

\EnglishThesisTitle{Application for Simulation of Database Problems}

\SubmissionDate{1. dubna 2019}

\Thanks{Rád bych zde poděkoval vedoucímu této bakalářské práce doc. Ing. Radimovi Bačovi  Ph.D. za jeho cenné rady a konzultace během tvorby práce.}

% Pokud nechceme nikomu dekovat makro zapoznamkujeme.
%\Thanks{Rád bych na tomto místě poděkoval všem, kteří mi s prací pomohli, protože bez nich by tato práce nevznikla.}

% Zadame cestu a jmeno souboru ci nekolika souboru s digitalizovanou podobou zadani prace.
% Pokud toto makro zapoznamkujeme sazi se stranka s upozornenim.
\ThesisAssignmentImagePath{Figures/Assignment}

% Zadame soubor s digitalizovanou podobou prohlaseni autora zaverecne prace.
% Pokud toto makro zapoznamkujeme sazi se cisty text prohlaseni.
%\AuthorDeclarationImageFile{Figures/AuthorDeclaration.jpg}


% Zadame soubor s digitalizovanou podobou souhlasu spolupracujici prav. nebo fyz. osoby.
% Pokud toto makro zapoznamkujeme sazi se cisty text souhlasu.
%\CooperatingPersonsDeclarationImageFile{Figures/CoopPersonDeclaration.jpg}


% řazeno podle abecedy nikoliv podle výskytů v textu
\AddAcronym{API}{Application Programming Interface}
\AddAcronym{CSV}{Comma-separated values}
\AddAcronym{DB}{Databáze}
\AddAcronym{DBMS}{Database Management system (Systém řízení báze dat)}
\AddAcronym{IDE}{Integrated Development Environment}
\AddAcronym{JAXB}{Java Architecture for XML Binding (\ref{jabx})}
\AddAcronym{JDBC}{Java Database Connectivity (\ref{jdbc})}
\AddAcronym{JRE}{Java Runtime Environment}
\AddAcronym{JVM}{Java Virtual Machine}
\AddAcronym{SQL}{Structured Query Language - Dotazovací jazyk pro manipulaci s daty na databázovém systému založeném na SQL}
\AddAcronym{SŘBD}{Systém řízení báze dat}
\AddAcronym{UML}{Unified Modeling Language}
\AddAcronym{XML}{eXtensible Markup Language}




\CzechAbstract{Tato bakalářská práce se zabývá simulováním problémů, které mohou nastat na databázovém serveru. Cílem práce je vytvořit aplikaci, která umožní definovat způsob vytížení databáze a simulovat reálný provoz. Správce databázového serveru tak má možnost vyzkoušet a odladit problémy, ještě před tím, než se databázový server uvede do reálného provozu.}

\CzechKeywords{SQL, databáze, simulace vytížení, validace SQL}

\EnglishAbstract{The purpose of this bachelor thesis is to simulate problems that could take place on a production database server. The objective is to create an application that will allow database administrators to specify the type of workload and simulate real database traffic. This way database administrators can find and solve performance problems that might come up during the test before using the database in a production environment.}

\EnglishKeywords{SQL, database, workload simulation, SQL validation}

% Zacatek dokumentu
\begin{document}

% Nechame vysazet titulni strany.
\MakeTitlePages


% A nasleduje text zaverecne prace.
\section{Úvod}
Databáze dnes stojí v pozadí téměř každé webové stránky, počítačového programu nebo mobilní aplikace. \par
V rámci bakalářského studijního plánu \textit{Informační a komunikační technologie} je vyučován předmět \textit{Administrace databázových systémů}, který je zaměřen na správu, monitorování a odhalování chyb ve fyzickém návrhu struktury databáze.
Cílem práce je vytvořit aplikaci pro simulaci problémů v databázovém systému, aplikace bude simulovat reálné situace, ve kterých se může databáze nacházet. Správce databáze tak může odhalit chyby nebo případné nedostatky ještě před nasazením systému do produkčního prostředí a předejít výpadkům dostupnosti databáze. \par
Tato práce se zabývá databázemi založených na SQL, veškeré operace nad databází tedy probíhají pomocí SQL. Aplikace, tvořena v rámci této práce, používá k simulaci reálného provozu na databázi sekvenci uživatelem definovaných SQL dotazů, které jsou na databázi zasílané v definovaném pořadí s určitým intervalem. Aplikace průběžně měří a zobrazuje výsledky testu.\par
V případě produkční databáze předpokládáme, že data musí být přístupná nepřetržitě, a že k datům bude přistupovat více vzdálených zařízení najednou. Proto jsou databáze často provozovány na samostatném počítači, pracovní stanici nebo serveru s velmi dobrou konektivitou do sítě a záložním zdrojem energie. Nicméně výkonný hardware nám v případě špatného fyzického návrhu struktury databáze nepomůže, proto vzniká tato aplikace.

\section{DBMS} \label{dbms}
\subsection{Obecné vlastnosti DBMS}
Database Management System (Systém řízení báze dat) je software pro správu dat, který umožňuje vytváření, editování, mazání a procházení dat, tato práce se zabývá systémy založené na dotazovacím jazyce SQL.

\subsection{Jazyk SQL (Structured Query Language)}
Jazyk SQL je doménově specifický jazyk standardizován organizací ISO (International Organization for Standardization) pod označením ISO/IEC 9075:2016 \cite{sqliso}. Samotný jazyk SQL se dá rozdělit do 4 kategorií:
\begin{itemize}
  \item \textbf{Data Query Language (DQL)} slouží pro procházení a čtení dat.
  \item \textbf{Data Definition Language (DDL)} se používá pro definování datových struktur.
  \item \textbf{Data Manipulation Language (DML)} aktualizuje, maže a přidává data.
  \item \textbf{Data Control Language (DCL)} se používá pro správu přístupu k datům.
\end{itemize}

V komplexnějších DBMS nalezneme ještě 5. kategorii \textbf{Declarative Language (deklarativní jazyk)}, také označován jako \textbf{procedurální rozšíření SQL}. Procedurální rozšíření jednotlivých DBMS se liší v syntaxi a neřídí se jednotným standardem. V případě Microsoft SQL Serveru se jazyk nazývá TransactSQL (T-SQL) a v případě Oracle Databáze se jazyk jmenuje PL/SQL.


\subsection{Vytížení databázového serveru}
Aplikace, tvořena v rámci této práce, bude databázový server zatěžovat opakovaným zasíláním sekvencí SQL dotazů definovaných uživatelem. Vytížení databázového serveru můžeme monitorovat pomocí následujících parametrů, ty můžeme vyčíst přímo z DBMS, případně z operačního systému, na kterém DBMS běží:
\begin{itemize}
  \item \textbf{Počet dotazů za vteřinu} - Počet dotazů za vteřinu je důležitý údaj, podle kterého můžeme porovnávat další parametry jako například vytížení procesoru, počet přístupů na disk nebo vytížení sítě. Toto číslo však nikdy nebude přímým ukazatelem vytížení, protože každý dotaz provádí odlišně náročné operace.
  \item \textbf{Doba zpracování dotazu} - Tento údaj je velmi důležitý, pokud monitorujeme dotazy na databázi, jejichž zpracování trvá dlouho. Můžeme tak odhalit problémy, zejména v samotném návrhu struktury databáze, nebo špatnou konstrukci SQL dotazů, které jsou na databázi zasílány. Nejdéle trvající operace budou z pravidla ty, které potřebují data číst, řadit nebo porovnávat sekvenčně.
  \item \textbf{Vytížení procesoru} - Je základní údaj, který je možné porovnávat s počtem dotazů na databázi. 
  \item \textbf{Počet přístupů na disk} - Každý správně navržený DBMS se snaží omezit počet přístupů na disk tím, že často používaná data načítá do části operační paměti nazývané jako vyrovnávací paměť. Při nedostatku operační paměti je databázový server nucen z disku opakovaně načítat stránky před vyhodnocením dotazu, které by jinak mohly být při dostatku operační paměti uloženy ve vyrovnávací paměti. Výsledkem je vysoký počet přístupů na disk a pomalý přístup k datům.
  \item \textbf{Počet SQL kompilací / rekompilací} - Pro každý SQL dotaz je na databázovém serveru sestavován plán jeho vykonání. Správně navržené aplikace by na databázový server měly posílat předem připravené SQL dotazy a za běhu aplikace zasílat na databázový server opakovaně stejně strukturované SQL dotazy jen s jinými argumenty. Protože sestavit plán vykonání dotazu je pro databázový server časově náročná operace, mělo by k sestavování docházet co nejméně. 
  \item \textbf{Vytížení sítě} - Při monitorování sítě sledujeme parametry:
  \begin{itemize}
  	\item \textbf{Délka fronty na síťovém rozhraní} - Pokud fronta na síťovém rozhraní dosahuje vysokých hodnot a kapacity linky není plně využita, může se jednat o problém s nedostatečným výkonem hardware síťového rozhraní (síťová karta).
  	\item \textbf{Rychlost odesílání / přijímaní dat} - Tento parametr je nutné porovnávat v celkovou propustností linky, kterou má databázový server k dispozici. 
  \end{itemize}
\end{itemize}


\section{Použitá technologie pro implementaci aplikace} \label{tech}

\subsection{Programovací jazyk Java}
Pro implementaci aplikace jsem zvolil programovací jazyk Java. Hlavní výhodou tohoto jazyka je přenositelnost aplikace mezi různými operačními systémy bez nutnosti úprav zdrojového kódu nebo jeho opětovného překladu. Tuto funkcionalitu zajišťuje prostředí JVM (Java Virtual Machine), které je součástí každé instalace JRE (Java Runtime Environment). Díky virtualizovanému prostředí JVM je zajištěno, že se aplikace bude chovat velmi podobně pod různými operačními systémy \cite{java}.

\subsection{JDBC (Java Database Connectivity)} \label{jdbc}
JDBC je API pro programovací jazyk Java, které definuje způsob, jak přistupovat k databázi. JDBC se používá na straně aplikace, která chce s databází komunikovat. JDBC požadavky aplikace přeloží na protokol, který využívá daný databázový systém. Výhodou JDBC je, že jeho zdrojový kód je veřejně dostupný, proto si každý výrobce databázového systému může JDBC implementovat. Tím je zajištěno, že k různým databázovým systémům se v prostředí programovacího jazyka Java přistupuje přes jednotné API \cite{jdbc}.


\subsection{Knihovna JavaFX pro grafické rozhraní}
JavaFX je platforma pro tvorbu grafických uživatelských rozhraní aplikací v programovacím jazyce Java. JavaFX se liší od ostatních grafických platforem, dostupných v základní instalaci Java Standard Edition, především tím, že grafické komponenty, jejich rozmístění a chování se definuje v odděleném souboru s příponou .FXML, tento soubor má formát XML. Každý FXML soubor definuje jedno grafické rozhraní (okno / scénu) a každý FXML soubor má přidruženou jednu nebo více tříd, které se označují jako "Controller". Tyto třídy pak zajišťují propojení grafických komponent se zbytkem aplikace. JavaFX se tak blíží návrhovému vzoru MVC (Model-View-Controller), ten je rozšířený zejména v oblasti web technologií \cite{javafx}.

\subsection{JAXB} \label{jabx}
Java Architecture for XML Binding (JAXB) je obsaženo v balíku \textit{javax.xml.bind}. JABX umožňuje serializovat Java objekty do formátu XML a uložit je na disk. Aby bylo možné objekt pomocí JABX serializovat, všechny datové typy, které objekt obsahuje musí implementovat rozhraní \textit{java.io.Serializable}. Chování serializace a de-serializace konkrétního objektu můžeme ovlivnit přidáním anotací do třídy, která objekt definuje. Anotace pro JAXB najdeme v balíku \textit{javax.xml.bind.annotation} \cite{jaxb}. V aplikaci jsou použity tyto anotace:
\begin{itemize}
  	\item \textbf{@XmlRootElement} umožňuje pojmenovat kořenový element XML pomocí argumentu \textit{name}.
  	\item \textbf{@XmlElement} označuje XML Element, pomocí nepovinného argumentu \textit{name} je možno element pojmenovat ve formátu XML. Bez použití této anotace budou všechny XML Elementy pojmenovány podle názvu třídních proměnných.
  	\item \textbf{@XmlElementWrapper} obalí XML Element dalším XML Elementem, v aplikaci použito především pro obalení seznamu elementů.
  	\item Proměnná označená anotací \textbf{@XmlTransient} se do XML formátu nebude serializovat.
  	\item \textbf{@XmlAttribute} umožňuje serializovat danou třídní proměnnou jako XML atribut.
\end{itemize}

\subsection{SceneBuilder}
JavaFX Scene Builder je nástroj pro vytváření uživatelských grafických rozhraní pro JavaFX. Jedná se o nástroj typu "WYSIWYG", což je zkratka pro "What You See Is What You Get", přeloženo "Co vidíte, to dostanete" \cite{sceneb}. Nástroj SceneBuilder umožňuje grafické komponenty "přetahovat", editovat jejich parametry jako odsazení od krajů, minimální, maximální a preferovanou velikost v interaktivním grafickém rozhraní. V prostředí SceneBuilder lze rovněž propojit grafické prvky s událostmi, jako například kliknutí na tlačítko, a nastavit odchycení této události v přidružené Controller třídě. Výstupem z tohoto programu je soubor formátu FXML, který je načten JavaFX aplikací \cite{scenebuilder}.

\begin{figure}[!h]\centering\includegraphics[width=1.0\textwidth]{Figures/SceneBuilder.png}\caption{Rozhraní nástroje SceneBuilder}
\end{figure}

\section{Specifikace aplikace}
Aplikace umožňuje definovat seznam \textbf{údajů k připojení k databázovým serverům} a otestovat jejich dostupnost. Dále umožňuje definovat \textbf{SQL dotazy s parametry}, ty mohou být definovány staticky nebo dynamicky pomocí uživatelem definovaných funkcí (viz sekce \ref{functions}) a ověřit správnost syntaxe těchto SQL dotazů (více v sekci \ref{parsers}).

Pokud máme definovány alespoň jedny údaje k připojení k databázovému serveru a alespoň jeden SQL dotaz můžeme vytvořit \textbf{spustitelnou úlohu}, ta obsahuje seznam údajů k připojení k jednomu nebo více databázovým serverům a seznam SQL dotazů s parametry, dále definuje počet opakování, interval opakování a počet paralelních spojení (detaily popsány v bodě 3. v sekci \ref{datastruct}). 

Grafické rozhraní aplikace je rozděleno do 2 hlavních oken. První je okno editoru, kde je možné editovat a přidávat \textbf{datové struktury} (viz sekce \ref{datastruct}), okno je dále rozděleno do tří záložek (obrázky \ref{coneditor}, \ref{sqleditor} a \ref{taskeditor}). Okno editoru se otevírá při spuštění aplikace. Z poslední záložky (obrázek \ref{taskeditor}) je možno otevřít druhé hlavní okno, které umožňuje spustit a sledovat průběh spustitelné úlohy (viz sekce \ref{taskmonitor}).

Podpora jednotlivých DBMS je zajištěna pomocí modulů, aby bylo možné jednoduše do aplikace přidat podporu pro další DBMS, bez nutnosti zasahovat do jádra aplikace. Detaily implementace modulů jsou popsány v sekci \ref{plugins}.

Pro zajištění co největší přehlednosti zdrojového kódu je implementace aplikace je rozdělena do tří vrstev:
\begin{itemize}
  	\item \textbf{Datová vrstva} se stará o ukládání, načítání a editování perzistentních dat v aplikaci. Datová vrstva je umístěna v balíku (Java package) \textit{dbstresstest.data}. Sekce \ref{datalayer} popisuje detaily této vrstvy.
  	\item \textbf{Prezentační vrstva} poskytuje grafické uživatelské rozhraní aplikace, ve kterém je možno vytvářet, editovat a mazat data aplikace. Dále pak spouštět a monitorovat úlohy. Prezentační vrstva je umístěna v balíku \textit{dbstresstest.gui}. Sekce \ref{presentlayer} popisuje detaily této vrstvy.
  	\item \textbf{Logická vrstva} zajišťuje vykonávání uživatelem spuštěných úloh, kontrolu uživatelského vstupu a komunikaci mezi datovou a prezentační vrstvou aplikace. Logická vrstva je umístěna v balíku \textit{dbstresstest.logic}. Sekce \ref{logiclayer} popisuje detaily této vrstvy.
\end{itemize} 

\section{Datová vrstva} \label{datalayer}

\subsection{Diagram tříd} \label{datadiagram}
\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/datadiagram.png}\caption{Diagram tříd datové vrstvy aplikace}
\end{figure}

\newpage

\subsection{Datové struktury} \label{datastruct}
Aplikace perzistentně ukládá následující datové struktury, v rámci aplikace jsou reprezentovány příslušnými třídami znázorněnými diagramem na obrázku \ref{datadiagram}. Na disku jsou tyto struktury uloženy ve formátu XML (více v sekci \ref{xml}).

\begin{enumerate}
  \item \textbf{Údaje k připojení k databázovému serveru} - Tento typ dat je v aplikaci reprezentován třídou \textbf{\emph{DbCon}}. Načítání a ukládání objektů, vytvořených z této třídy, do perzistentního úložiště provádí třída \textbf{\emph{ConManager}} (formát popsán v sekci \ref{xml}). Třída je realizována podle návrhového vzoru Singleton, aby bylo zaručeno, že za běhu aplikace bude existovat pouze jedna kopie dat v operační paměti aplikace. Třída \textbf{\emph{DbCon}} zapouzdřuje tyto data:
\begin{itemize}
  	\item \textit{id} - unikátní identifikátor na logické a datové vrstvě aplikace (viz sekce \ref{logic})
  	\item \textit{customName} - unikátní jméno definované uživatelem, slouží jako identifikátor na prezentační vrstvě (více v sekci \ref{prezent})
  	\item \textit{databaseName} - jméno databáze
  	\item \textit{databaseType} - rozšíření aplikace, které bude použito pro připojení k databázovému serveru (více v sekci \ref{plugins})
  	\item \textit{address} - adresa databázového serveru (v případě Microsoft SQL Server může~obsahovat~jméno instance)
  	\item \textit{user} - databázový uživatel
  	\item \textit{password} - heslo databázového uživatele, používá kódování Base64
  	\item \textit{port} - číslo portu databáze, hodnota 0 značí výchozí hodnotu v JDBC řadiči
\end{itemize}
  
  \item \textbf{SQL dotazy s parametry} - Tento typ dat reprezentuje třída \textbf{\emph{SQLSet}}. Načítání a ukládání objektů těchto tříd realizuje třída \textbf{\emph{SetManager}} (formát popsán v sekci \ref{xml}), která je taktéž implementována podle návrhového vzoru Singleton. Třída \textbf{\emph{SQLSet}} zapouzdřuje tyto data:
    \begin{itemize}
  	\item \textit{id} - unikátní identifikátor na logické a datové vrstvě aplikace (\ref{logic})
  	\item \textit{name} - unikátní jméno definované uživatelem, slouží jako identifikátor na prezentační vrstvě (více v sekci \ref{prezent})
  	\item \textit{sql} - SQL dotaz v textové podobě
  	\item \textit{values} - pole objektů \textbf{\emph{ValueSet}}, každý objekt reprezentuje jednu sadu parametrů SQL dotazu
  	\item \textit{databaseType} - rozšíření aplikace, které bude kontrolovat syntaxi SQL dotazu
  	\item \textit{query} - označuje, zda se jedná o SQL dotaz, který bude číst data
  	\item \textit{update} - označuje, zda se jedná o SQL dotaz, který bude zapisovat nebo modifikovat data
  	\item \textit{call} - označuje, zda se jedná o SQL dotaz, který bude volat uloženou proceduru nebo funkci
  	\item \textit{lineDelimiter} - znak, který označuje konec řádku s parametry
  	\item \textit{paramDelimiter} - znak, který odděluje jednotlivé parametry od sebe
  	\item \textit{timeout} - limit v milisekundách pro vykonání dotazu
  \end{itemize}
  
  \item \textbf{Spustitelné úlohy} - Tyto data jsou reprezentovány třídou \textbf{\emph{Task}}. O načítání a ukládání do perzistentního úložiště se opět stará Singleton třída \textbf{\emph{TaskManager}} (formát popsán v sekci \ref{xml}). Objekty třídy \textbf{\emph{Task}} obsahují tyto data:
    \begin{itemize}
  	\item \textit{id} - unikátní identifikátor na logické a datové vrstvě aplikace (viz sekce \ref{logic})
  	\item \textit{taskName} - unikátní jméno definované uživatelem, slouží jako identifikátor  na prezentační vrstvě (více v sekci \ref{prezent})
  	\item \textit{sets} - posloupnost ID odkazující na objekty \textit{SQL dotazů s parametry} (viz bod 2. v tomto seznamu)
  	\item \textit{databases} - pole ID odkazující na objekty \textit{údajů k připojení k databázovému serveru} v této úloze (viz bod 1. v tomto seznamu)
  	\item \textit{interval} - interval v milisekundách, ve kterém se bude úloha opakovat
  	\item \textit{poolSize} - maximální počet spojení s databázovým serverem, které může úloha v jednu chvíli využívat
  	\item \textit{repeatCount} - počet opakování úlohy, hodnota \textit{-1} značí nekonečný počet opakování
    \end{itemize}
\end{enumerate}

Všechny Singleton Manager třídy (popsané na začátku této sekce) mají možnost zaregistrovat posluchače událostí pomocí generické třídy \textbf{\emph{ManagerListener}}  pomocí volání metody \textit{addListener(listener)}, která je součástí každé Manager třídy, jako argument je předaná vytvořená instance generického posluchače. Třída posluchače je generická, aby mohla být použitá pro všechny Manager třídy (\textbf\emph{{ConManager, SetManager, TaskManager}}). Tyto posluchače jsou v aplikaci využity v Prezentační vrstvě pro aktualizaci seznamů vytvořených entit, zachycuje se událost \textit{onListChanged(List<T> objects)} vyvolávaná Manager třídami při editaci uložených datových struktur aplikace.

\newpage
\subsection{XML datové soubory} \label{xml}
Perzistentní data aplikace jsou uložena ve formátu XML, vyjma Log a CSV souborů, ty jsou popsány v sekci \ref{logs}.\newline

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Údaje k připojení k databázovému serveru ve formátu XML\label{lst:con},language=XML] 
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<connections>
    <connection id="1548773964597">
        <address>127.0.0.1</address>
        <customName>Test</customName>
        <databaseName>Test</databaseName>
        <databaseType>MSSQL</databaseType>
        <password></password>
        <port>0</port>
        <user>Test</user>
    </connection>
</connections>
\end{lstlisting}
Všechny \textbf{údaje k připojení k databázovému serveru} (bod 1. v sekci \ref{datastruct}) jsou uloženy v jednom XML souboru. Standardní umístění tohoto souboru je \textit{data/connections.xml}, kde adresář \textit{data} je umístěna v pracovním adresáři aplikace. Důvodem uložení do jednoho souboru je možnost přímé editace tohoto XML pomocí jiného externího nástroje nástroje. Formát tohoto XML souboru byl stanoven vedoucím této práce.
\end{minipage}

\lstset{aboveskip=30pt}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=SQL dotazy s parametry ve formátu XML\label{lst:set},language=XML] 
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<sql call="false" type="MSSQL" id="1549662678705" lineDelimiter="59" name="MujSelect" paramDelimiter="44" parametrized="true" query="true" text="select * from test;" timeout="100" update="false"/>
\end{lstlisting}
Sady \textbf{SQL dotazů s parametry} (bod 2. v sekci \ref{datastruct}) jsou uloženy ve více XML souborech, umístěných v adresáři \textit{data/sql/}, adresář \textit{data} je umístěn v pracovním adresáři aplikace. Každý soubor reprezentuje jeden uložený SQL dotaz, případně jeho parametry, pokud se jedná o parametrizovaný dotaz. Jméno souboru se shoduje s parametrem ID (Identity), které slouží jako unikátní identifikátor daného uloženého SQL dotazu. Aplikace generuje tyto ID na základě aktuálního času v milisekundách od 1.1.1970 v době vytváření SQL dotazu v rozhraní aplikace.
\end{minipage}

\lstset{aboveskip=30pt}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Spustitelná úloha ve formátu XML\label{lst:task},language=XML] 
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workload id="1552506883608" interval="1000" poolSize="1" repeatCount="-1" taskName="SuperTest">
    <databases>
        <database>1548773964597</database>
        <database>1550072873964</database>
    </databases>
    <sql>1549662678705</sql>
    <sql>1550513479135</sql>
</workload>
\end{lstlisting}
Každá \textbf{spustitelná úloha} (bod 3. v sekci \ref{datastruct}) je uložená v samostatném XML souboru v adresáři \textit{data/tasks/}, adresář \textit{data} je umístěn v pracovním adresáři aplikace. Soubor obsahuje reference pomocí ID.
\end{minipage}

\subsection{Log a CSV soubory} \label{logs}
Během spouštění úloh v aplikaci jsou generovány log soubory, obsahují informace a všech chybách, které nastaly za běhu dané úlohy. Log soubory jsou umístěny v adresáři \textit{/logs}, ten je umístěn v pracovním adresáři aplikace. Log soubory jsou rozděleny podle jména uložených údajů k připojení k databázovému serveru a dále pak podle data spuštění úlohy, aby bylo možné dobře v log souborech vyhledávat a případně mazat nepotřebné adresáře s log soubory.

Pokud úloha skončí nebo je zastavená uživatelem, aplikace nabídne možnost výsledky testu exportovat do CSV souboru. Do souboru jsou exportovány časy vykonávání jednotlivých SQL dotazů. Díky CSV formátu je možno s daty dále pracovat v jiném externím nástroji a vygenerovat z dat grafy.

\section{Prezentační vrstva} \label{presentlayer}
\textbf{Prezentační vrstva} poskytuje uživatelské rozhraní aplikace, ve kterém je možno vytvářet, editovat a mazat data aplikace. Dále pak spouštět a monitorovat úlohy. Prezentační vrstva je umístěna v balíku \textit{dbstresstest.gui}.
\subsection{Digram tříd} \label{prezent}
Proměnné JavaFX elementů jsou v následujícím diagramu znázorněny pouze jejich Java balíkem \textit{javafx.scene.control}, ze kterého pocházejí, z důvodu velkého počtu těchto proměnných.

\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/presentlayer.png}\caption{Diagram tříd prezentační vrstvy aplikace}\label{presentdiagram}
\end{figure}

Uživatelské rozhraní aplikace je definováno v FXML souborech. Tyto soubory jsou umístěny v balíku \textit{dbstresstest.gui.fxml}. Každý FXML soubor tvoří jedno okno aplikace a je mu přiřazena právě jedna JavaFX Controller třída pomocí argumentu \textit{fx:controller} v FXML souboru. Controller třída propojuje uživatelské rozhraní s logickou vrstvou aplikace, reaguje na akce uživatele a zpracovává události vyvolané během práce s grafickým rozhraním aplikace, pracuje tedy na pomezí prezentační a logické vrstvy.

Controller třída obsahuje referenci na všechny prvky uživatelského rozhraní, pomocí které lze k prvkům přistupovat a měnit jejich vlastnosti za běhu aplikace. Reference se předává do třídních proměnných jejichž název se musí shodovat s \textit{fx:id} prvku definovaného v FXML souboru. Reference na aktuální instanci prvku rozhraní JavaFX předává během inicializace controller třídy, aby předávání fungovalo, controller třída musí implementovat rozhraní \textit{javafx.fxml.Initializable}.

Aplikace celkem obsahuje 4 hlavní okna a k nim jsou přiřazeny 4 Controller třídy \newline \textbf{\emph{MainWindowController, RunningTaskController, HelpWindowController a ImportConController}}. Všechny Controller třídy mají vazby (zobrazeno třídním diagramem na obrázku \ref{presentdiagram}) na Singleton třídu GUI, tato třída obsahuje pomocné funkce pro vyvolávání dodatečných dialogových oken. 

Třída \textbf{\emph{MainWindowController}} dále využívá pomocné třídy pro ovládání některých složitějších komponent. Třídy \textbf{\emph{DragDropDB}} a \textbf{\emph{DragDropSQL}} zajišťují funkcionalitu přetahování prvků sql a údajů k připojení k databázi v editoru úloh. Třída \textbf{\emph{ContextMenus}} vytváří kontextové nabídky v hlavním okně. V diagramu tříd prezentační vrstvy aplikace se dále nachází statické výčtové třídy \textbf{\emph{KeyShortcuts}} (obsahuje výčet klávesových zkratek) a \textbf{\emph{Tabs}} (obsahuje výčet záložek hlavního okna aplikace, jejich pořadí a jména).

\textbf{\emph{DatabaseTypeConverter}} rozšiřuje třídu \textit{javafx.util.StringConverter} a upravuje její funkcionalitu pro \textbf{\emph{DatabasePlugin}} třídy v naší aplikaci (viz sekce \ref{plugins}).

Třída \textbf{\emph{WindowResizeListener}} reaguje na události spojené s změnou velikosti okna aplikace a přizpůsobuje tomu velikost některých grafických prvků. Jedná se především o ovládací prvky \textit{javafx.scene.control.SplitPane}, které ve výchozím stavu nereagují na změny velikosti okna a nezachovávají si proporční velikosti nastavené uživatelem. Třída se inicializuje společně s \textbf{\emph{MainWindowController}} třídou, tyto třídy tak na sebe nemají přímou vazbu.

\newpage
\subsection{Hlavní okno aplikace}
Po spuštění aplikace je spuštěno hlavní grafické uživatelské rozhraní, to je rozděleno do tří podsekcí (záložek) pomocí \textit{javafx.scene.control.TabPane}.


\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/coneditor.png}\caption{Okno editoru údajů k připojení k databázovému serveru}\label{coneditor}
\end{figure}
Záložka editoru (obrázek \ref{coneditor}) pro správu \textbf{\emph{údajů k připojení k databázovému serveru}} umožňuje přidávat nové položky pomocí tlačítka umístěného pod seznamem položek, nebo přes hlavní kontextovou nabídku aplikace. Existující položky lze editovat po kliknutí na jejich jméno v seznamu umístěného na levé straně okna. Pravým kliknutím na jméno položky, lze položku trvale odstranit. Samotný formulář odpovídá datové struktuře třídy \textbf{\emph{DbCon}} (viz sekce \ref{datadiagram}). Heslo databázového uživatele se zadává do vstupního pole typu \textit{javafx.scene.control.PasswordField}, díky tomu se na monitor renderují pouze zástupné znaky \textbf{'•'}, místo skutečných znaků hesla.

Nad uloženými údaji lze provést test, tento test ověří, zda se k danému databázovému serveru lze připojit.

\newpage
\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/sqleditor.png}\caption{Okno editoru SQL dotazů s parametry}
\label{sqleditor}
\end{figure}
Okno editoru \textbf{\emph{SQL dotazů s parametry}} (obrázek \ref{sqleditor}) obsahuje formulář odpovídající datové struktuře třídy \textbf{\emph{SQLSet}} (viz sekce \ref{datadiagram}). Ve formuláři funguje také kontrola syntaxe SQL, aby kontrola fungovala, je potřeba nejdříve vybrat typ databáze, pro kterou je SQL určeno (na výběr jsou opět všechny aktuálně načtené rozšíření aplikace, které obsahují implementaci SQL praseru, více o rozšířeních aplikace v sekci \ref{plugins}). Pro definování parametrizovaných příkazů používáme symbol \textbf{\emph{ '?' }} jako zástupný znak parametru v SQL a jeho hodnotu vyplňujeme v textové oblasti níže. Každý parametr musí být oddělen ve výchozím nastavení znakem \textbf{\emph{ ',' }}, tento znak je možno ve formuláři změnit. Pokud chceme tento příkaz během jeho spuštění provést více krát po sobě, můžeme definovat několik sad parametrů tím, že je oddělíme ve výchozím nastavení znakem \textbf{\emph{ ';' }}, pro přehlednost zápisu můžeme oddělit i novým řádkem, to ale není povinné. Oddělovač sady parametrů lze v rámci formuláře změnit na jiný znak. Místo staticky definovaných parametrů můžeme použít zabudované funkce aplikace (viz sekce \ref{functions}).


\newpage
\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/taskeditor.png}\caption{Okno editoru spustitelných úloh}
\label{taskeditor}
\end{figure}
Okno editoru pro konstrukci \textbf{\emph{spustitelných úloh}} (obrázek \ref{taskeditor}) vytváří datové struktury odpovídající datové struktuře třídy \textbf{\emph{Task}} (viz sekce \ref{datadiagram}). Ve formuláři definujeme \textbf{\emph{SQL dotazy s parametry}}, které se budou spouštět v každém cyklu (opakování) úlohy a SQL servery (\textbf{\emph{údaje k připojení k databázovému serveru}}), na kterých úloha poběží. 

Z tohoto rozhraní můžeme úlohu spustit a dále monitorovat pomocí okna monitoru popsaného v následující sekci \ref{taskmonwin}.

\newpage
\subsection{Okno monitoru úloh} \label{taskmonwin}
\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/taskmongui.png}\caption{Okno monitoru úloh}
\label{taskmonitor}
\end{figure}
Okno monitoru úlohy (obrázek \ref{taskmonitor}) je samostatné okno aplikace zobrazující  průběžné statistiky běžící \textbf{\emph{spustitelné úlohy}}. Pokud úloha současně běží na více databázových serverech, je mezi jednotlivými servery možné přepínat pomocí levého panelu. Všechny informace v okně se vždy vztahují pouze k aktuálně vybranému databázovému serveru. 

V prostředním panelu se zobrazuje konzole úlohy, zde jsou vidět prováděné příkazy a také případné chyby a jejich popis. Konzole je limitovaná na posledních 200 událostí. Konzole se v průběhu automaticky posouvá směrem dolů. Důležité události, především chyby a varování jsou ukládány také do log souboru na disku (log soubory popsány v sekci \ref{logs}). V pravém panelu se zobrazují statistiky úlohy:
\begin{itemize}
\item \textbf{loops} - aktuální počet provedených opakování úlohy
\item \textbf{queries} - celkový počet provedených SQL dotazů
\item \textbf{total time} - celková doba běhu úlohy 
\item \textbf{total query time} - celkový čas strávený dotazováním databázového serveru (nezahrnuje žádné jiné operace související s konstrukcí příkazů nebo výpočty hodnot funkcí)
\item \textbf{pool status} - aktuální stav využitých / maximálně možných spojení a čekajících (idle) otevřených spojení
\end{itemize}

V pravém panelu pod celkovými statistikami následuje tabulka statistik pro každý \textbf{\emph{SQL dotaz s parametry}} samostatně. Je zde možné monitorovat průměrný čas provedení dotazu, počet vykonání dotazu a počet chyb, které v tomto dotazu nastaly. Také se zde zobrazuje čas posledního úspěšně provedeného dotazu a čas poslední chyby.

Časy ze kterých se vypočítává průměrný čas pro každý \textbf{SQL dotaz s parametry} je možné po skončení nebo zastavení úlohy vyexportovat do CSV souboru a pomocí externích nástrojů z nich vygenerovat grafy (CSV soubory popsány v sekci \ref{logs}).



\newpage
\section{Logická vrstva} \label{logiclayer}
\textbf{Logická vrstva} zajišťuje vykonávání uživatelem spuštěných úloh, kontrolu uživatelského vstupu a komunikaci mezi datovou a prezentační vrstvou aplikace. Logická vrstva je umístěna v balíku \textit{dbstresstest.logic}.
\subsection{Diagramy průběhu úlohy} \label{logic}
Následující sekvenční diagram demonstruje proces přípravy \textbf{spustitelné úlohy} na její spuštění. Vstupem je objekt typu \textbf{\emph{Task}} (viz bod 3 v sekci \ref{datastruct}). Výstupem tohoto procesu je seznam položek typu \textbf{\emph{RunnableTask}}. Objekt typu \textbf{\emph{RunnableTask}} je vytvořen pro každý databázový server definován v této spustitelné úloze.

\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/rtprocess.png}\caption{Sekvenční diagram vytvoření spustitelné úlohy}
\label{seq1}
\end{figure}

\textbf{\emph{MainWindowController}} je třída spojující prezentační a logickou vrstvu aplikace (viz sekce \ref{prezent}). Po vyvolání události pro spuštění vybrané úlohy v prezentační vrstvě tato třída volá statickou metodu \textit{createRunnable(Task)} umístěnou ve statické třídě \textbf{\emph{RunnableTaskCreator}}, která vytvoří pole objektů \textbf{\emph{RunnableTask}}, pro každou databázi v této úloze je vytvořen právě jeden tento objekt.

Objekty typu \textbf{\emph{RunnableTask}} vytváří v konstruktoru sadu objektů, které implementují rozhraní \textbf{\emph{ExecutableQuery}} (implementace rozhraní se liší podle typu dotazu), pro každý samostatný SQL dotaz v dané úloze, je vytvořen právě jeden objekt. Pokud se jedná o parametrizovaný SQL příkaz, pak se pro každou sadu parametrů, se kterou se má dotaz spouštět, vytvoří pole objektů typu \textbf{\emph{Var}}. Tyto objekty zapouzdřují veškeré chování proměnných, rozpoznávají datové typy a vyhodnocují hodnoty funkcí. Během vytváření objektů typu \textbf{\emph{Var}} je určen datový typ parametru, který objekt uchovává, pokud se jedná o funkci, dochází k rozpoznání funkce a argumentů, tento proces je popsán diagramem \ref{seqvar} (propojení diagramů je označeno znakem modré hvězdy).


Na konci diagramu je vytvořené pole objektů RunnableTask předáno v konstruktoru třídy  \textbf{\emph{RunnableTaskController}} (v diagramu zkráceno na \textit{RTController}). Daná úloha je v tuto chvíli připravena ke spuštění. Průběh úlohy je dále znázorněn diagramem \ref{seqruntask}.


\begin{figure}[!htbp]\centering\includegraphics[width=0.8\textwidth]{Figures/var.png}\caption{Sekvenční diagram vytvoření objektu typu Var}
\label{seqvar}
\end{figure}


\newpage


\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/runtask.png}\caption{Sekvenční diagram průběhu úlohy}
\label{seqruntask}

\textit{ThreadPool a RunnableTaskThread (označeny šedým pozadím) nejsou samostatné třídy, jsou součástí třídy \textbf{\emph{RunnableTask}}, v diagramu jsou zobrazeny na samostatných osách, aby bylo možné lépe popsat, operace prováděné na jednotlivých vláknech aplikace. }
\end{figure}


Diagram \ref{seqruntask} popisuje průběh spuštění úlohy od chvíle, kdy uživatel klikne na tlačítko start, tuto akci zachytí posluchač ve třídě \textbf{\emph{RunnableTaskController}} (v diagramu zkráceno na~\textit{RTController})~a~v~cyklu spustí úlohu pro všechny definované databáze v úloze metodou \textit{start()} volanou na objekty \textbf{\emph{RunnableTask}}, jejich vytvoření popisuje předchozí diagram \ref{seq1}. Dále je v rámci objektu \textbf{\emph{RunnableTask}} vytvořen objekt typu \textit{DbPool} pomocí statické třídy \textbf{\emph{RunnableTaskCreator}}, \textit{DbPool} je rozhraní, které definuje operace pro \textit{Connection Pool} (posloupnost předem vytvořených spojení s databázovým serverem). Implementace třídy \textit{DbPool} se liší v závislosti na typu databáze. Jednotlivé DBMS spravují samostatné rozšíření hlavní aplikace (viz sekce \ref{plugins}).


Před samostatným spuštěním je ještě potřeba vytvořit Thread pool (posloupnost předem vytvořených vláken, v diagramu označeno jako \textit{ThreadPool}, pro implementaci je použit \newline \textit{java.util.concurrent.ExecutorService}), velikost je shodná s velikostí Connection poolu. Aby bylo možné zajistit funkcionalitu neomezeného počtu spuštění, které je ukončeno až akcí uživatele, je potřeba vytvořit další vlákno (v diagramu označeno jako \textit{RunnableTaskThread} (zelené ohraničení v diagramu), které bude časovat a odesílat jednotlivé SQL dotazy k vykonání do \textit{Thread Poolu} pomocí metody \textit{submit(RunnableTask)} (třída rozšiřuje rozhraní java.lang.Runnable a proto může být předána do \textit{ThreadPoolu}).

V jednotlivých vláknech \textit{Thread Poolu} (označeno červenou barvou v diagramu) je spouštěna metoda \textit{execute(task, pool)}. Tato požádá o volné připojení k databázovému serveru pomocí \textit{getConnection()}. Následuje vytvoření samotného SQL příkazu, který se bude zasílat na databázový server. Z důvodu rozsáhlosti diagramu je tato operace znázorněna v samostatném diagramu \ref{getvalues} Jako poslední operace ve vlákně \textit{thread poolu} se vyvolají události a uloží se informace o vykonaném SQL dotazu.


\begin{figure}[!htbp]\centering\includegraphics[width=0.75\textwidth]{Figures/getvalues.png}\caption{Sekvenční diagram sestavení Statement objektu a jeho parametrů}
\label{getvalues}
\end{figure}

Diagram \ref{getvalues} popisuje průběh metody \textit{execute()} z předchozího diagramu \ref{seqruntask} (označeno znakem červené hvězdy). Pro každou sadu parametrů SQL dotazu se volá postupně pro každý parametr metoda \textit{getValue()} na objekty \textbf{\emph{Var}}, jejich vytvoření bylo popsáno v předchozím diagramu \ref{seqvar}. Získaná hodnota je poté dosazena do \textit{java.sql.Statement}, po dosazení všech hodnot je \textbf{Statement} odeslán na databázový server pomocí vlastní metody \textit{execute()}.

\newpage
\subsection{Uživatelem definované funkce} \label{functions}
Pro parametrizaci dotazu je možné použít, místo staticky definovaných parametrů, uživatelem definované funkce, které parametry generují. Funkce jsou vyhodnocovány před zasláním SQL dotazu. Pokud se dotaz v rámci \textbf{\emph{spustitelné úlohy}} má opakovat, pak je funkce vyhodnocena před každým opakováním znovu. Aplikace momentálně obsahuje 2 funkce, nicméně rozhraní aplikace je připraveno pro jednoduchou implementaci dalších funkcí. Každá funkce je obalena mezi znaky \textbf{\#\{ FUNKCE \}} pro jednoznačnou detekci, že se jedná o funkci.
\begin{itemize}
\item
\textit{Funkce} \textbf{randomInt(MIN,MAX)}:\newline
Funkce generuje náhodné číslo v zadaném rozsahu, maximální rozsah generovaného čísla a přijímaných argumentů funkce je velikost Java Integer čísla.


\textit{Argumenty:}\newline
MIN - definuje minimální velikost generovaného čísla (povinný argument)\newline
MAX - definuje maximální velikost generovaného čísla (povinný argument)\newline

\textit{Výjimky:}\newline
InvalidFunctionException - se vyvolá v případě špatných argumentů funkce\newline

\textit{Příklad použití funkce:}\newline
\#\{randomInt(1,10)\} - vygeneruje náhodné číslo v rozsahu 1 až 10


\item
\textit{Funkce} \textbf{randomCharEnum(enum)}:\newline
Funkce generuje náhodnou posloupnost znaků z předem zadané posloupnosti znaků (viz sekce \ref{charenums}). Délka generované posloupnosti odpovídá celkovému počtu znaku v předané posloupnosti v argumentu.


\textit{Argumenty:}\newline
enum - jméno posloupnosti znaků, která bude použita pro generování nové náhodné posloupnosti\newline

\textit{Výjimky:}\newline
InvalidFunctionException - v případě, že se nepodaří nalézt posloupnost předanou v argumentu funkce během inicializace funkce\newline
FunctionEvaluationException - se vyvolá v případě, že předaná posloupnost v argumentu funkce je prázdná nebo pokud má špatný formát\newline

\textit{Příklad použití funkce:}\newline
\#\{randomCharEnum(A)\} - vygeneruje náhodnou posloupnost znaků z posloupnosti se jménem '\textit{A}', ta musí být definována v aplikaci (viz sekce \ref{charenums})

\end{itemize}

\subsection{Znakové posloupnosti} \label{charenums}
Znakové posloupnosti se používají pro generování náhodných posloupností znaků v uživatelsky definovaných funkcích (viz sekce \ref{functions}). V hlavním menu aplikace (\textit{CharEnums -> Edit}) je možné pomocí systémového výchozího editoru pro textové soubory (s příponou \textit{.txt}) editovat soubor, ve kterém jsou definovány tyto posloupnosti. Po editaci souboru je nutné pomocí hlavního menu tyto posloupnosti znovu načíst do paměti aplikace (\textit{CharEnums -> Reload}).

\subsection{Rozšíření aplikace} \label{plugins}
Aby bylo možné zajistit kompatibilitu s více DBMS bez nutnosti zasahovat do zdrojového kódu aplikace je tato funkcionalita zajištěna pomocí rozšíření hlavní aplikace. Jedná se o samostatný .JAR soubor, který aplikace načítá. Všechny rozšíření jsou umístěny v adresáři \textit{/plugins}, ten se nachází v domovském adresáři aplikace. Každé rozšíření aplikace obsahuje následující komponenty:
\begin{itemize}
\item \textbf{JDBC řadič} - implementace JDBC pro daný DBMS, jedná se o externí knihovnu přibalenou uvnitř JAR souboru rozšíření. Tuto knihovnu poskytuje většina DBMS na svých oficiálních webových stránkách ke stažení.
\item \textbf{Connection pool} - umožňuje předpřipravit posloupnost spojení s databázovým serverem. Samotná implementace může být v každém rozšíření jiná, každé rozšíření ale musí implementovat rozhraní hlavní aplikace - \textbf{\emph{DbPool}} (viz diagram na obrázku \ref{pluginsdiag}).
\item \textbf{SQL Parser} - každý DBMS může vyžadovat jiný SQL Parser, proto je umístěn v rozšíření, nikoliv v hlavní aplikaci, více v sekci \ref{parsers}. 
\end{itemize}


\newpage
\begin{figure}[!htbp]\centering\includegraphics[width=1.0\textwidth]{Figures/plugins.png}\caption{Třídní diagram rozšíření aplikace}
\label{pluginsdiag}
\end{figure}

V balíku aplikace \textit{dbstresstest.plugins} se nachází třída \textbf{\emph{DatabasePlugin}}, kterou musí každé rozšíření rozšířit a implementovat (přepsat pomocí @Override anotace) všechny její metody. Jméno .JAR souboru rozšíření musí odpovídat cestě ke hlavní třídě rozšíření, která rozšiřuje třídu \textbf{\emph{DatabasePlugin}}. Při načítání rozšíření aplikace prochází všechny .jar soubory umístěné v adresáři \textit{/plugins} a pokud tento soubor obsahuje třídu, která rozšiřuje třídu \textbf{\emph{DatabasePlugin}}, pak dojde k načtení třídy rozšíření. Rozšíření je poté dostupné v aplikaci pod jménem získaného z metody \textit{getName()}. O načítání a později i k přistupování k rozhraním načtených rozšíření se stará třída \textbf{\emph{PluginLoader}}, ta uchovává seznam načtených pluginů, které jsou poté k dispozici v aplikaci.

Rozšíření se načítají při spuštění hlavní aplikace, pro přidání nového rozšíření je potřeba aplikaci restartovat. Odebrání nebo přejmenování (změna metody \textit{getName()} v hlavní třídě rozšíření) rozšíření způsobí nefunkčnost všech \textbf{\emph{spustitelných úloh}}, které dané rozšíření používaly.



\newpage
\section{Validace SQL dotazů - SQL Lexer / Parser} \label{parsers}
Jeden z cílů této práce je validovat SQL zadané uživatelem. Aby bylo možné zkontrolovat správnost zadaného SQL dotazu, potřebujeme znát kompletní gramatiku jazyka SQL a nad touto gramatikou postavit validátor (parser). Protože tohle téma je tak rozsáhlé, že by mohlo pokrýt celou samostatnou práci, použijeme na validaci SQL příkazů již existující knihovny. Před samotným výběrem knihovny, jsem prováděl testy volně dostupných knihoven pro zpracovávání SQL. Pro jazyk Java, co se volně dostupných knihoven týká, máme pouze 2 projekty, které jsou aktuální a stále se rozvíjí, projekt ANTRL a projekt jsqlparser.


\subsection{Projekt ANTLR (ANother Tool for Language Recognition)}
Projekt ANTRL je nástroj na čtení, zpracovávání, vykonávání nebo překládání strukturovaného textu nebo binárních souborů. Je velmi rozšířený pro budování jazyků, nástrojů a knihoven. ANTRL vygeneruje ze zadané gramatiky parser, který umožňuje sestavovat a procházet sestavené stromy ze zadané posloupnosti výrazů. \cite{antrl}



ANTRL využívá pro psaní gramatiky 2 soubory, aktuální verze ANTRL je 4, proto tyto soubory mají koncovku .g4. Soubor Lexer.g4 obsahuje veškerou gramatiku, kterou daný jazyk využívá, druhý soubor Parser.g4 obsahuje pravidla zpracovávaného jazyka. Jako jsou například posloupnosti klíčových slov jazyka a hodnoty mezi klíčovými slovy. Tyto soubory mají specifickou syntaxi ANTRL, tuto gramatiku ANTRL překladač zpracuje a vygeneruje zdrojový kód v programovacím jazyce Java, nebo jiném, který požadujeme. Vygenerované zdrojové kódy poté vložíme do naší aplikace. \cite{antrldocs}



Výhoda ANTRL spočívá v tom, že gramatiky jsou umístěny na serveru github.com a jsou tak otevřené k editaci pro širokou veřejnost vývojářů. Případné chyby, které se v gramatice mohou objevit může opravit kdokoliv. ANTRL navíc nabízí gramatiky specifické pro různé verze jazyka SQL jako T-SQL, PL-SQL, MySQL a SQLite, které se liší především ve svých procedurálních rozšířeních. \cite{antrlg}



Největším problémem ANTRL je samotná práce programátora s vygenerovanými zdrojovými kódy, pokud se jedná o velmi rozsáhlý jazyk jako SQL. Pro jazyk Java a gramatiku pro PL-SQL ANTRL vygeneruje soubor PlSqlParser.java, který má více než 167 000 řádků kódu. Ve vývojovém prostředí NetBeans IDE 8.2, pro jazyk Java, takto velký soubor nelze otevřít z důvodu nedostatku paměti, kterou nástroj potřebuje při načítání souboru.

\begin{table}[!htbp]
	\centering
	\caption{Počet řádků vygenerovaných zdrojových kódů ANTRL pro jazyk Java}
	\label{tab:parsers}
	\begin{tabular}{lllll}
		\toprule
		Parser & Lexer.java & Parser.java\\
		\midrule
		PL-SQL & 13 540 & 167 114 \\
        T-SQL & 4 611 & 98 484 \\
        MySQL & 5 108 & 60 411 \\
		\midrule
	\end{tabular}
\end{table}


Problémem existujících gramatik na oficiální github.com stránce projektu ANTRL je to, že k nim existuje pouze minimální nebo žádná dokumentace a tím, že každá gramatiku byla psána jinými lidmi, vznikají poté ve vygenerovaných zdrojových kódech odlišnosti. Například pokud chceme zobrazit stromovou strukturu SQL DML (Data Manipulation Language) dotazu, v každé gramatice je vygenerovaná metoda s odlišným názvem, kde \textit{parser} je reference na instanci parser třídy (tabulka \ref{tab:parsers}) vygenerované z dané gramatiky:\newline

\begin{lstlisting}[caption=T-SQL Parser]

parser.dml_clause().toStringTree();
\end{lstlisting}

\begin{lstlisting}[caption=PL-SQL Parser]

parser.data_manipulation_language_statements().toStringTree();
\end{lstlisting}

\begin{lstlisting}[caption=MySQL Parser]

parser.dmlStatement().toStringTree();
\end{lstlisting}

\newpage

\subsection{Testy ANTRL}
Právě díky tomu, že automaticky vygenerované třídy pomocí ANTRL jsou tak rozsáhlé, první vytvoření instance tříd v JVM je velmi pomalé, protože dochází k překladu Java kódu (bytecode). Opakované spouštění, nad již vytvořenými instancemi parser tříd, je již podstatně rychlejší, protože kód je již uložen v paměti JVM (v části paměti pojmenované jako \textit{Code Cache}), kde je uložen již přeložený Java kód (bytecode) na nativní strojový kód.

\begin{table}[!htbp]
	\centering
	\caption{ANTRL Test 1}
	Výsledky pro dotaz: 'SELECT * FROM TEST'
	\vskip 0.1cm
	\label{tab:antrl1}
	\begin{tabular}{lllll}
		\toprule
		Parser & První spuštění & Opakované spuštění & Správnost vyhodnocení\\
		\midrule
		PL-SQL & 1831 ms & 2 ms & Ano \\
        T-SQL & 525 ms & 1 ms & Ano \\
        MySQL & 428 ms & 1 ms & Ano \\
		\midrule
	\end{tabular}
\end{table}

\begin{table}[!htbp]
	\centering
	\caption{ANTRL Test 2}
	Výsledky pro dotaz: 'SELECT ** FROM TEST'
	\vskip 0.1cm
	\label{tab:antrl2}
	\begin{tabular}{lllll}
		\toprule
		Parser & První spuštění & Opakované spuštění & Správnost vyhodnocení\\
		\midrule
		PL-SQL & 1207 ms & 68 ms & Ano \\
        T-SQL & 416 ms &31 ms & Ne \\
        MySQL & 322 ms & 1 ms & Ne \\
		\midrule
	\end{tabular}
\end{table}

\begin{table}[!htbp]
	\centering
	\caption{ANTRL Test 3}
	Výsledky pro dotaz: 'SELECT COUNT(*) FROM TEST WHERE CID = 5 AND PRICE < 100 GROUP BY NAME ORDER BY PRICE'
	\vskip 0.1cm
	\label{tab:antrl3}
	\begin{tabular}{lllll}
		\toprule
		Parser & První spuštění & Opakované spuštění & Správnost vyhodnocení\\
		\midrule
		PL-SQL & 2556 ms & 5 ms & Ano \\
        T-SQL & 450 ms & 6 ms & Ano \\
        MySQL & 364 ms & 6 ms & Ano \\
		\midrule
	\end{tabular}
\end{table}

\begin{table}[!htbp]
	\centering
	\caption{ANTRL Test 4}
	Výsledky pro dotaz: 'SELECT COUNT(*) FROM TEST WHERE CID = 5 AND PRICE < 100 GROUP BY NAME ORDER PRICE'
	\vskip 0.1cm
	\label{tab:antrl4}
	\begin{tabular}{lllll}
		\toprule
		Parser & První spuštění & Opakované spuštění & Správnost vyhodnocení\\
		\midrule
		PL-SQL & 2522 ms & 6 ms & Ano \\
        T-SQL & 479 ms & 6 ms & Ne \\
        MySQL & 364 ms & 5 ms & Ano \\
		\midrule
	\end{tabular}
\end{table}


Z testů je vidět, že T-SQL a MySQL ANTRL parser nedokázal odhalit chybu ve špatné syntaxi dotazu \textit{SELECT ** FROM TEST} (viz tabulka \ref{tab:antrl2}). T-SQL parser poté opakovaně selhal (viz~tabulka~\ref{tab:antrl4}).



\subsection{Projekt Jsqlparser}
Projekt jsqlparser je postavený na knihovně JavaCC, která je vyvíjena samotnou společností Oracle. JavaCC je nástroj, který ze specifikace gramatiky dokáže vygenerovat zdrojové kódy v programovacím jazyce Java, umožňuje také sestavování stromové struktury jazyka pomocí nástroje JJTree, který je součástí JavaCC knihovny \cite{jsql}.


Nástroj Jsqlparser překládá dotaz jazyka SQL na ekvivalentní hierarchii Java tříd. Jsqlparser podporuje speciální SQL syntaxi pro Oracle, SqlServer, MySQL a PosgreSQL. Výsledek zpracovaného dotazu je možné strukturovaně procházet pomocí návrhového vzoru Visitor \cite{jsqld}.


\subsection{Testy Jsqlparser}
Pro možnost testy porovnat, jsou v testu použity stejné SQL dotazy, jako v předchozím testu ANTRL. Díky tomu, že Jsqlparser je univerzální a nemá gramatiky pro různé variace jazyka SQL nijak odděleny, nemůžeme porovnat rychlost zpracovávání dotazů pro PL-SQL, T-SQL a MySQL odděleně, jako v předchozím ANTRL testu. Pro měření opakovaného spouštění pro stejný dotaz bylo nutné použít v tomto testu měření v nanosekundách.

\begin{table}[!htbp]
	\centering
	\caption{JSqlparser test 1}
	Výsledky pro dotaz: 'SELECT * FROM TEST'
	\vskip 0.1cm
	\label{tab:jsql1}
	\begin{tabular}{lllll}
		\toprule
		Parser & První spuštění & Opakované spuštění & Správnost vyhodnocení\\
		\midrule
		Jsql & 30 ms & 0.26 ms & Ano \\
		\midrule
	\end{tabular}
\end{table}

\begin{table}[!htbp]
	\centering
	\caption{JSqlparser test 2}
	Výsledky pro dotaz: 'SELECT ** FROM TEST'
	\vskip 0.1cm
	\label{tab:jsql2}
	\begin{tabular}{lllll}
		\toprule
		Parser & První spuštění & Opakované spuštění & Správnost vyhodnocení\\
		\midrule
		Jsql & 29 ms & 0.34 ms & Ano \\
		\midrule
	\end{tabular}
\end{table}

\begin{table}[!htbp]
	\centering
	\caption{JSqlparser test 3}
	Výsledky pro dotaz: 'SELECT COUNT(*) FROM TEST WHERE CID = 5 AND PRICE < 100 GROUP BY NAME ORDER BY PRICE'
	\vskip 0.1cm
	\label{tab:jsql3}
	\begin{tabular}{lllll}
		\toprule
		Parser & První spuštění & Opakované spuštění & Správnost vyhodnocení\\
		\midrule
		Jsql & 33 ms & 0.59 ms & Ano \\
		\midrule
	\end{tabular}
\end{table}

\begin{table}[!htbp]
	\centering
	\caption{JSqlparser test 4}
	Výsledky pro dotaz: 'SELECT COUNT(*) FROM TEST WHERE CID = 5 AND PRICE < 100 GROUP BY NAME ORDER PRICE'
	\vskip 0.1cm
	\label{tab:jsql4}
	\begin{tabular}{lllll}
		\toprule
		Parser & První spuštění & Opakované spuštění & Správnost vyhodnocení\\
		\midrule
		Jsql & 33 ms & 0.75 ms & Ano \\
		\midrule
	\end{tabular}
\end{table}


\subsection{Srovnání parser knihoven}
Výsledky testování prokázaly, že JSqlparser bude pro naše účely vhodnější. Hlavním důvodem proč jsem pro jsem se rozhodl v aplikaci použít JSqlparser je fakt, že ANTRL parser vyhodnocuje dotaz při prvním spuštění více než vteřinu a v případě delších SQL dotazů až více než 2 vteřiny, jak ukazují předchozí testy. Taková doba je nepřijatelná, pokud chceme SQL validovat v reálném čase během doby, kdy uživatel SQL zadává do aplikace. Doba, kterou ANTRL parser vyžaduje, by způsobila pozastavení reakcí celé aplikace na akce uživatele během zadávání SQL dotazu, pokud by měla aplikace validovat SQL a v reálném čase zobrazovat výsledek. Díky rychlým odpovědím z JSqlParser je možné implementovat tento parser synchronně, ANTRL parser by vyžadoval asynchronní implementaci a výsledky by se zobrazovaly s prodlevou, výsledek validace by tak nemusel vždy odpovídat momentálnímu vstupu od uživatele.




\section{Závěr}
Cílem práce bylo vytvořit aplikaci s grafickým rozhraním pro zasílání posloupností SQL dotazů na vybrané DBMS pro podporu výuky předmětu \textit{Administrace databázových systémů}. Díky technologii programovacího jazyka Java je možné aplikaci spouštět na všech operačních systémech, které jí podporují. Aplikaci není nutné instalovat, jedná se o jediný spustitelný .JAR soubor, který nepotřebuje žádné argumenty. Dále je potřeba adresář s rozšířeními (\textbf{/plugins}), ten obsahuje rozšíření pro MS SQL Server, Oracle, MySQL a H2 databázové systémy, všechny jsou vyučovány v rámci předmětu \textit{Administrace databázových systémů}. Rozšíření pro H2 bylo do práce přidáno v rámci projektu "Zprovoznění vybraného DBMS", který byl součástí výuky předmětu \textit{Administrace databázových systémů}.

Aplikaci je dobře optimalizovaná, takže i při testování několika (10 až 20) databázových systémů paralelně po dobu několika hodin si aplikace drží využití operační paměti v rozmezí 300 - 500 MB. Využití paměti záleží však na parametrech \textbf{-Xms} (počáteční paměť JVM) a \textbf{-Xmx} (maximální paměť JVM).

Díky modularitě aplikace je možné aplikaci použít pro jakýkoliv databázový systém založený na SQL. Přidat další rozšíření do aplikace je velmi jednoduché, jedná se o implementaci 2 tříd, jak je popsáno v sekci \ref{plugins}. V rámci aplikace je pomocí hlavního menu možné zobrazit podrobný postup, jak nové rozšíření implementovat v prostředí nástroje NetBeans 8.2.

Podle zadání, aplikace využívá pro perzistentní data formát XML, který umožňuje i manuální editaci pomocí externích nástrojů. Výstup statistik z aplikace je ve formátu CSV, se kterým je opět možné dále pracovat v externích nástrojích. 

































\begin{thebibliography}{99}
	\bibitem{antrl} Terence Parr. ANTLR (ANother Tool for Language Recognition) [online]. [cit. 2019-03-02]. Dostupné z: https://www.antlr.org/
	\bibitem{antrldocs} ANTRL Docs [online]. [cit. 2019-03-06]. Dostupné z: https://github.com/antlr/antlr4/blob/master/doc/index.md
	\bibitem{antrlg} ANTRL přehled dostupných gramatik [online]. [cit. 2019-03-02]. Dostupné z: https://github.com/antlr/grammars-v4
	\bibitem{jsql} The Java Parser Generator [online]. [cit. 2018-11-20]. Dostupné z: https://javacc.org/
	\bibitem{jsqld} JSql parser dokumentace [online]. [cit. 2019-03-10]. Dostupné z: https://github.com/JSQLParser/JSqlParser/wiki
	\bibitem{scenebuilder} Cindy Castillo. JSBGS.BOOK: JavaFX Scene Builder Getting Started with JavaFX Scene Builder Release 2.0 2014 [online]. [cit. 2019-03-10]. Dostupné z: https://docs.oracle.com/javase/8/scene-builder-2/JSBGS.pdf
	\bibitem{netbeans} A Brief History of NetBeans [online]. [cit. 2019-03-12]. Dostupné z: https://netbeans.org/about/history.html
	\bibitem{sqliso} Information technology -- Database languages -- SQL [online]. [cit. 2019-03-22]. Dostupné z: https://www.iso.org/standard/63555.html
	\bibitem{java} Java 8 SE dokumentace [online]. [cit. 2019-04-18]. Dostupné z: https://docs.oracle.com/javase/8/docs/
	\bibitem{jdbc} JDBC dokumentace [online]. [cit. 2019-04-18]. Dostupné z: https://www.oracle.com/technetwork/java/overview-141217.html
	\bibitem{javafx} JavaFX dokumentace [online]. [cit. 2019-04-18]. Dostupné z: https://docs.oracle.com/javase/8/javase-clienttechnologies.htm
	\bibitem{jaxb} JAXB dokumentace [online]. [cit. 2019-04-18]. Dostupné z: https://docs.oracle.com/javase/8/docs/technotes/guides/xml/jaxb/index.html
	\bibitem{sceneb} JavaFX Scene Builder dokumentace [online]. [cit. 2019-04-18]. Dostupné z: https://www.oracle.com/technetwork/java/javase/downloads/javafxscenebuilder-info-2157684.html
	
	
	
	
	
	
	
	
	
	
	
	
	
	
\end{thebibliography}


\appendix % prilohy
\section{Zdrojový kód pro testování ANTRL - MySQL}
\begin{lstlisting}[caption=ANTRL MySQL]

	import antrl.mysql.MySqlParser;
	import antrl.mysql.MySqlLexer;
	import org.antlr.v4.runtime.*;

    static boolean mysqlresult = true;

    public static boolean mysql(String args) {
        mysqlresult = true;
        long start = System.currentTimeMillis();
        System.out.println("MySQL Check: " + args);
        CharStream stream = new ANTLRInputStream(args);
        MySqlLexer lexer = new MySqlLexer(stream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);

        MySqlParser parser = new MySqlParser(tokens);

        parser.addErrorListener(new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int pos, String msg, RecognitionException e) {
                System.out.println("Failed to parse at " + line + "," + pos + ":  " + msg);
                mysqlresult = false;
            }
        });
        parser.dmlStatement().toStringTree(parser);
        System.out.println("MySQL Result: " + mysqlresult + ", took: " + (System.currentTimeMillis()-start) + "ms");
        return mysqlresult;
    }
\end{lstlisting}
\section{Zdrojový kód pro testování ANTRL - T-SQL}
\begin{lstlisting}[caption=ANTRL T-SQL]

	import antrl.tsql.TSqlLexer;
	import antrl.tsql.TSqlParser;
	import org.antlr.v4.runtime.*;

  	static boolean tsqlresult = true;

    public static boolean tsql(String args) {
        tsqlresult = true;
        long start = System.currentTimeMillis();
        System.out.println("TSQL Check: " + args);
        CharStream stream = new ANTLRInputStream(args);
        TSqlLexer lexer = new TSqlLexer(stream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        
        TSqlParser parser = new TSqlParser(tokens);

        parser.addErrorListener(new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int pos, String msg, RecognitionException e) {
                System.out.println("Failed to parse at " + line + "," + pos + ":  " + msg);
                tsqlresult = false;
            }
        });
        parser.dml_clause().toStringTree(parser);
        System.out.println("TSQL Result: " + tsqlresult + ", took: " + (System.currentTimeMillis()-start) + "ms");
        return tsqlresult;
    }
\end{lstlisting}
\section{Zdrojový kód pro testování ANTRL - PL-SQL}
\begin{lstlisting}[caption=ANTRL PL-SQL]

	import antrl.plsql.PlSqlLexer;
	import antrl.plsql.PlSqlParser;
	import org.antlr.v4.runtime.*;

    static boolean plsqlresult = true;

    public static boolean plsql(String args) {
        plsqlresult = true;
        long start = System.currentTimeMillis();
        System.out.println("PLSQL Check: " + args);
        CharStream stream = new ANTLRInputStream(args);
        PlSqlLexer lexer = new PlSqlLexer(stream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);

        PlSqlParser parser = new PlSqlParser(tokens);

        parser.addErrorListener(new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int pos, String msg, RecognitionException e) {
                System.out.println("Failed to parse at " + line + "," + pos + ":  " + msg);
                plsqlresult = false;
            }
        });
        parser.data_manipulation_language_statements().toStringTree();
        System.out.println("PLSQL Result: " + plsqlresult + ", took: " + (System.currentTimeMillis()-start) + "ms");
        return plsqlresult;
    }
}
\end{lstlisting}


\section{Zdrojový kód pro testování JsqlParser}
\begin{lstlisting}[caption=ANTRL JSQL]
    public static boolean parse(String sql) {
        try {
            Statements st = CCJSqlParserUtil.parseStatements(sql);
            st.getStatements().get(0);
            return true;
        } catch (Exception ex) {
            System.out.println(ex.getCause().getMessage());
            return false;
        }
    }
\end{lstlisting}

\end{document}
